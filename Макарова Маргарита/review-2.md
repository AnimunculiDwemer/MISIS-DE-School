- [ ] **Дефект.** Во время игры предлагается ввести сначала строку, а затем столбец. Однако, фактически столбцы и строчки перепутаны местами. 

Пример:
```
Изначальное поле для игры
0 0 0 
0 0 0 
0 0 0 
Введите координаты клетки, в которой вы хотите поставить крестик(X) или нолик(O)
Координата столбца: 1
Координата строки: 2
Ход X
0 0 0 
0 0 X 
0 0 0 
```

Представляется, что правильное состояние поля должно быть следующим:
```
Ход X
0 0 0 
0 0 0 
0 X 0 
```


- [ ] **Дефект.** В программе нет защиты от перезаписи чужого хода, крестик может перезаписать нолик и наоборот.

```
Изначальное поле для игры
0 0 0 
0 0 0 
0 0 0 
Введите координаты клетки, в которой вы хотите поставить крестик(X) или нолик(O)
Координата столбца: 1
Координата строки: 2
Ход X
0 0 0 
0 0 X 
0 0 0 
Введите координаты клетки, в которой вы хотите поставить крестик(X) или нолик(O)
Координата столбца: 1
Координата строки: 2
Ход O
0 0 0 
0 0 O 
0 0 0 
```


- [ ] **Неоптимальный код.** Функции `CheckX()` и `CheckO()` реализованы с достаточно большой избыточностью, в частности следующий участок кода
```
for i in range(len(mas)):
    for k in range(len(mas[i])):
        print(mas[i][k], end = " ")
    print()
```
повторяется многократно. Предлагается данный участок кода оформить в виде отдельной функции (например, что-то в духе `PrintField()`), которую всюду далее вызывать. 

Также, предлагается подумать о том, чтобы объединить функции `CheckX()` и `CheckO()` в новую функцию `Check(player)`, в которую в качестве входного аргумента `player` передавать "значок" игрока: 'X' или 'O'. Это позволит сделать кодовую базу более сбалансированной.


- [ ] **Неоптимальный код.** В предлагаемом участке кода организован цикл по переменной `i` и `k`:
```
        if ((a==0 or a==1 or a==2)and(b==0 or b==1 or b==2)):
            if count % 2!=0:
                print("Ход X")
                for i in range(3):
                    for k in range(3):
                        if i==a and k==b:
                            mas[i][k]="X"
                            count+=1
```
цикл перебирает 9 различных комбинаций пар значений указанных переменных, однако, при этом только для одной комбинации предусмотрено активное действие:
```
                        if i==a and k==b:
                            mas[i][k]="X"
                            count+=1
```
Кажется, что рассматриваемый участок кода можно значительно упростить. Предлагается сделать это.
